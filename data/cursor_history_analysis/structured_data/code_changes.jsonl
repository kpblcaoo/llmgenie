{"session_id":"5f6ecbec","file_id":"HFlu.py","type":"code_change","timestamp":1749477056867,"target_file":"src/llmgenie/orchestration/agent_orchestrator.py","summary":"Implementation of Multi-Agent Orchestrator (AgentOrchestrator) with parallel, sequential, and collaborative execution modes. Leverages existing TaskRouter/ModelRouter components. Includes task decomposition, quality validation, and coordination logging.","code_elements":{"classes":["ExecutionMode","AgentCoordination","OrchestrationTask","OrchestrationResult","AgentOrchestrator"],"methods":["coordinate_multi_agent_tasks","_execute_parallel","_execute_sequential","_execute_collaborative","_decompose_task","_calculate_quality_score","_validate_result_quality","_log_coordination_event","get_coordination_metrics","manage_parallel_execution","handle_inter_agent_communication"],"imports":["TaskClassifier","ModelRouter","ModelChoice","RoutingDecision","QualityValidator","QualityResult"]},"raw_content_preview":"\"\"\"\nAgent Orchestrator for Multi-Agent Task Coordination\n\nEpic 5 Phase 3.1: Multi-Agent Orchestration implementation\nExtends existing TaskRouter/ModelRouter with orchestration capabilities.\n\nDesign principle: Composition over inheritance - leverages existing components.\n\"\"\"\n\nfrom typing import Dict, List, Optional, Union, Any\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport asyncio\nimport json\n\n# Import existing Epic 5 components\nfrom ..task_router import (\n    TaskClassifier, \n    ModelRouter, \n    ModelChoice, \n    RoutingDecision,\n    QualityValidator,\n    QualityResult\n)\n\n\nclass ExecutionMode(Enum):\n    \"\"\"Multi-Agent execution patterns from Epic 5 checklist\"\"\"\n    PARALLEL = \"parallel\"        # Parallel task execution (documentation + code generation)\n    SEQUENTIAL = \"sequential\"    # Sequential handoffs (design → implementation → review)\n    COLLABORATIVE = \"collaborative\"  # Collaborative problem solving (multiple models, best result)\n\n\nclass AgentCoordination(Enum):\n    \"\"\"Agent coordination strategies\"\"\"\n    INDEPENDENT = \"independent\"  # Agents work independently\n    SYNCHRONIZED = \"synchronized\"  # Agents synchronize results\n    HIERARCHICAL = \"hierarchical\"  # Lead agent coordinates others\n\n\n@dataclass\nclass OrchestrationTask:\n    \"\"\"Task for multi-agent orchestration\"\"\"\n    task_id: str\n    query: str\n    context: Optional[Dict] = None\n    execution_mode: ExecutionMode = ExecutionMode.PARALLEL\n    coordination: AgentCoordination = AgentCoordination.INDEPENDENT\n    subtasks: Optional[List[str]] = None\n    priority: int = 1\n    timeout_seconds: int = 300\n\n\n@dataclass \nclass OrchestrationResult:\n    \"\"\"Result of multi-agent orchestration\"\"\"\n    task_id: str\n    status: str  # \"completed\", \"partial\", \"failed\"\n    results: Dict[str, Any]  # Results from individual agents\n    execution_time: float\n    quality_score: Optional[float] = None\n    coordination_efficiency: Optional[float] = None\n    error: Optional[str] = None\n    metadata: Optional[Dict] = None\n\n\nclass AgentOrchestrator:\n    \"\"\"\n    Multi-Agent Orchestrator for Epic 5 Phase 3 Production Ready\n    \n    Coordinates multiple TaskRouter instances for complex multi-agent workflows.\n    Implements patterns from Epic 5 checklist: parallel, sequential, collaborative execution.\n    \n    Design: Composition with existing TaskRouter/ModelRouter components\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize orchestrator with TaskRouter components\"\"\"\n        # Leverage existing Epic 5 components\n        self.classifier = TaskClassifier()\n        self.quality_validator = QualityValidator()\n        \n        # Orchestration state\n        self.active_tasks: Dict[str, OrchestrationTask] = {}\n        self.agent_routers: Dict[str, ModelRouter] = {}\n        self.coordination_log: List[Dict] = []\n        \n        # Initialize multiple ModelRouter instances for multi-agent coordination\n        self._initialize_agent_routers()\n    \n    def _initialize_agent_routers(self):\n        \"\"\"Initialize specialized ModelRouter instances for different agent roles\"\"\"\n        # Primary agents based on Epic 5 architecture\n        self.agent_routers = {\n            \"primary\": ModelRouter(self.classifier),       # Main task execution\n            \"secondary\": ModelRouter(self.classifier),     # Backup/validation  \n            \"specialist\": ModelRouter(self.classifier),    # Specialized tasks\n        }\n    \n    async def coordinate_multi_agent_tasks(self, complex_task: OrchestrationTask) -> OrchestrationResult:\n        \"\"\"\n        Main coordination method for multi-agent tasks\n        \n        Epic 5 Phase 3.1 requirement: coordinate_multi_agent_tasks\n        \"\"\"\n        start_time = datetime.now()\n        self.active_tasks[complex_task.task_id] = complex_task\n        \n        try:\n            # Task decomposition based on execution mode\n            if complex_task.execution_mode == ExecutionMode.PARALLEL:\n                result = await self._execute_parallel(complex_task)\n            elif complex_task.execution_mode == ExecutionMode.SEQUENTIAL:\n                result = await self._execute_sequential(complex_task)\n            elif complex_task.execution_mode == ExecutionMode.COLLABORATIVE:\n                result = await self._execute_collaborative(complex_task)\n            else:\n                raise ValueError(f\"Unknown execution mode: {complex_task.execution_mode}\")\n            \n            # Calculate metrics\n            execution_time = (datetime.now() - start_time).total_seconds()\n            result.execution_time = execution_time\n            \n            # Quality validation using existing QualityValidator\n            result.quality_score = await self._calculate_quality_score(result)\n            \n            # Log coordination event\n            self._log_coordination_event(complex_task, result)\n            \n            return result\n            \n        except Exception as e:\n            error_result = OrchestrationResult(\n                task_id=complex_task.task_id,\n                status=\"failed\",\n                results={},\n                execution_time=(datetime.now() - start_time).total_seconds(),\n                error=str(e)\n            )\n            return error_result\n        \n        finally:\n            # Cleanup\n            self.active_tasks.pop(complex_task.task_id, None)"}
