# Докладная записка №1: Структура project_state.json, логика правил и роли

---

## 1. Верхнеуровневая карта проекта (overview)

**Вопрос:**
Какие ключевые компоненты и цели проекта должны быть отражены в overview?

- [+] CLI (интерфейс командной строки)
- [+] API (FastAPI, интеграции)
- [+] Модули (основные подпроекты: llmgenie, llmstruct и т.д.)
- [+] JSON-структуры (ideas, tasks, sessions, state и т.д.)
- [+] Документация (README, onboarding, best practices)
- [ ] Другие (допиши): должны дополняться по мере появления новых. overview должны быть отдельными для каждого проекта. 

**Твой выбор/комментарии:**

---

## 2. Детализированная карта (details)

**Вопрос:**
Что важно включить в подробное описание компонентов?

- [+] Назначение компонента
- [+] Основные функции
- [+] Ключевые файлы/пути
- [+] Связи с другими частями
- [+] Версия, автор, дата обновления
- [+] Ссылки на документацию/примеры
- [ ] Другие (допиши):

**Твой выбор/комментарии:**

---

## 3. Раздел "rules" (правила)

**Вопросы:**
- Какие группы правил должны быть отражены?
  - [+] Жёсткие (branch policy, session management, logging, workflow-modes)
  - [+] Ситуативные (enforcement, ai-capabilities, project_scope)
  - [ ] Другие (допиши):

- Какой формат описания правил тебе удобнее?
  - [ ] Кратко (id, имя, тип, сценарии активации)
  - [ ] Подробно (все метаданные, ссылки, best practices)
  - [+] Оба варианта (overview + details)

**Твой выбор/комментарии:**

---

## 4. Manifest для правил (rules_manifest.json)

**Вопрос:**
Какие поля и метаданные должны быть у каждого правила?

- [+] id, имя
- [+] Тип (жёсткое/ситуативное)
- [+] Сценарии активации (авто/ручной/по роли)
- [+] Приоритет
- [+] Описание
- [+] Связанные роли/режимы
- [+] Ссылки на документацию/примеры
- [ ] Другие (допиши):

**Твой выбор/комментарии:**

---

## 5. Роли и режимы

**Вопрос:**
Какие роли и режимы ты видишь в проекте?
(например: user, llm_engineer, reviewer, admin, guest, и т.д.)

- [+] user
- [+] llm_engineer
- [+] reviewer
- [+] admin
- [ ] guest
- [ ] Другие (допиши): librarian(работа с докумментацией), devops, user обсудим(мб для обсуждения с точки зрения юзабилити?), admin для работы с ос и софтом мб. Это не ограничение, а помощь в удержании фокуса для ЛЛМ, чтобы она не забивала голову ненужными в данный момент вещами, но могла их посмотреть если надо. МБ ещё роли нужны

**Как роли должны влиять на активацию и видимость правил?**
(например: admin видит и может менять все, user — только часть, llm_engineer — может активировать ситуативные и т.д.)

**Твой выбор/комментарии:**

---

## 6. Организация хранения JSON-файлов

**Вопрос:**
Какую структуру папок считаешь оптимальной для хранения json-файлов?

- [ ] По подсистемам (data/llmgenie/, data/llmstruct/, data/common/)
- [ ] Все в одном data/
- [+] Другое (допиши): llmgenie и llmstruct это отдельные, хоть и связанные проекты. кроме того, мы будем их применять и в других проектах. поэтому, думаю, вариация первого пункта

**Твой выбор/комментарии:**

---

## 7. Дополнительные пожелания/идеи

**Твой текст:**
нужно тщательно с llm-инженером проработать .cursor/rules. Прицепил на подумать анализ от грока(сам понимаешь, может и врать с каким-то шансом). Учти, что примеры - это примеры, а не то что надо принимать сейчас как правила:

Отчет: Подробный обзор возможностей .cursor/rules и их продвинутых применений
Введение
.cursor/rules — это конфигурационные файлы, интегрированные в IDE Cursor AI, которые служат для направления поведения искусственного интеллекта. Они предоставляют постоянный контекст и инструкции, помогая ИИ следовать заданным рекомендациям и предпочтениям разработчиков. Это особенно полезно для автоматизации задач, стандартизации стиля кода и адаптации ИИ под специфику проекта. Данный отчет подробно описывает возможности .cursor/rules, их продвинутые применения, примеры и лучшие практики, основываясь на доступной информации на 01:07 PM EEST, 04 июня 2025 года.

Типы правил и их структура
Существуют два основных типа правил:

Проектные правила (Project Rules): Хранятся в директории .cursor/rules в корне проекта, являются версионируемыми и специфичны для данного кода. Они позволяют адаптировать поведение ИИ под уникальные требования проекта. Например, можно создать правило для директории backend/.cursor/rules/ в монопроектах для специфичных настроек бэкенда.
Пользовательские правила (User Rules): Определяются глобально в настройках Cursor (Cursor Settings > Rules) и применяются ко всем проектам. Они подходят для личных предпочтений, таких как стиль ответа (например, формальный или неформальный тон) или часто используемые библиотеки. Формат — простой текст, всегда включены.
Ранее использовался файл .cursorrules в корне проекта, но он считается устаревшим, и рекомендуется переходить на систему Project Rules для большей гибкости и контроля.

Правила могут быть следующих типов:

Всегда применяемые (Always): Указаны с alwaysApply: true, применяются ко всем взаимодействиям.
Автоматически прикрепляемые (Auto Attached): Применяются на основе шаблонов файлов, указанных в globs: ["pattern"], с alwaysApply: false.
Запрашиваемые агентом (Agent Requested): ИИ может запросить правило на основе описания, указанного в description: "...".
Ручные (Manual): Требуют явного упоминания, например, с помощью @ruleName.
Возможности .cursor/rules
.cursor/rules предоставляют следующие ключевые возможности:

Постоянный контекст: Когда правило применяется (автоматически или вручную), его содержимое добавляется в начало запроса к модели ИИ (Agent или Cmd-K). Это обеспечивает последовательное поведение ИИ, независимо от задачи — генерация кода, интерпретация изменений или помощь в рабочих процессах.
Гибкость настройки: Возможность задавать правила как глобально, так и локально позволяет адаптировать ИИ под разные сценарии. Например, глобальные правила могут установить общий стиль ответа, а проектные — специфические стандарты для кода.
Интеграция с рабочими процессами: Правила поддерживают автоматизацию, например, генерацию сообщений коммитов или обнаружение ошибок, упрощая повседневные задачи разработчиков.
Продвинутые применения
Продвинутые способы использования .cursor/rules включают:

Кодирование знаний домена: Правила могут предоставлять ИИ специфические знания о проекте или домене, улучшая релевантность и точность предложений. Например, правило может описывать архитектуру проекта, используемые фреймворки или бизнес-логику, что особенно полезно для сложных систем.
Автоматизация рабочих процессов и шаблонов: Правила могут автоматизировать повторяющиеся задачи, такие как создание шаблонов для часто используемых структур кода (например, шаблоны для API-эндпоинтов) или генерация документации. Это ускоряет разработку и снижает вероятность ошибок.
Стандартизация стиля кода и архитектуры: Правила могут обеспечивать соблюдение стандартов кодирования, таких как форматирование в стиле Python Black, архитектурные практики для Django или React, или использование определенных библиотек. Это помогает поддерживать единообразие в команде и улучшает читаемость кода.
Контекст для конкретного проекта: Хранение правил в .cursor/rules позволяет адаптировать ИИ под уникальные требования проекта. Например, для монопроектов правила можно организовать в вложенных директориях, таких как .cursor/rules/ для общих настроек и backend/.cursor/rules/ для специфичных для бэкенда.
Глобальные предпочтения: Пользовательские правила в настройках Cursor позволяют задавать личные предпочтения, применимые ко всем проектам, например, тон ответов (формальный или неформальный) или предпочтительный стиль кодирования.
Примеры продвинутых правил
Ниже приведены конкретные примеры правил, демонстрирующие их возможности:


Название правила	Описание	Шаблоны файлов (Globs)	Всегда применять	URL (если применимо)
Лучшие практики для Django	Направляет ИИ следовать рекомендациям по моделям, представлениям, шаблонам и ORM.	["*.py"]	false	-
Лучшие практики для Dockerfile	Рекомендации по написанию эффективных и безопасных Dockerfile.	["Dockerfile", "*.Dockerfile"]	false	-
Форматирование Python Black	Гарантирует соответствие кода стилю форматирования Black.	["*.py"]	false	-
Лучшие практики для React	Описывает подходы к написанию современных компонентов и приложений React.	[".js", ".jsx", ".ts", ".tsx"]	false	-
Эти примеры показывают, как правила могут быть адаптированы под различные технологии и сценарии. Например, правило для Django может включать инструкции по использованию ORM, а правило для React — рекомендации по хукам и управлению состоянием.

Лучшие практики по созданию правил
Для эффективного использования .cursor/rules рекомендуется:

Компактность: Сохранять правила менее 500 строк, чтобы избежать перегрузки ИИ.
Примеры: Включать примеры в правила для ясности ожидаемого поведения, например, показать, как должен выглядеть отформатированный код.
Декомпозиция: Делить сложные концепции на меньшие правила, чтобы упростить управление и повысить читаемость. Например, вместо одного большого правила для всего проекта лучше создать отдельные правила для бэкенда и фронтенда.
Конкретность: Избегать нечетких инструкций, предпочитая конкретные и ясные указания, чтобы избежать путаницы для ИИ. Например, вместо "используй лучшие практики" лучше указать "всегда добавляй аннотации типов в Python".
Дополнительные функции и особенности
Генерация правил: Правила можно генерировать из чата, используя команду /Generate Cursor Rules, что упрощает создание новых инструкций.
Быстрое создание: Новые правила можно создать быстро, используя Cmd + Shift + P > “New Cursor Rule”, что особенно удобно для опытных пользователей.
Организация в монопроектах: Для сложных проектов, таких как монопроекты, правила можно организовать в вложенных директориях, например, .cursor/rules/ для общих настроек и backend/.cursor/rules/ для специфичных для бэкенда, обеспечивая гибкость.
Командные правила: Хотя встроенной поддержки командных правил пока нет, их можно хранить в отдельном репозитории или использовать символические ссылки (symlinks) для подключения к .cursor/rules, что полезно для командной работы.
Как работают правила
Правила применяются следующим образом: когда правило активируется (автоматически на основе шаблонов файлов или вручную через @ruleName), его содержимое добавляется в начало запроса к модели ИИ. Это обеспечивает, что ИИ всегда учитывает заданные инструкции, независимо от задачи — будь то генерация кода, интерпретация изменений или помощь в рабочих процессах. Например, если правило указывает "всегда используй аннотации типов в Python", ИИ будет следовать этому при каждом взаимодействии с Python-файлами.

Заключение
.cursor/rules — мощный инструмент для управления поведением ИИ в IDE Cursor, позволяющий адаптировать его под конкретные нужды разработчиков. Используя продвинутые применения, такие как кодирование знаний домена, автоматизация рабочих процессов и стандартизация стиля кода, разработчики могут значительно повысить продуктивность и качество кода. Примеры, такие как правила для Django, Dockerfile, Python Black и React, демонстрируют гибкость и практическую ценность этого подхода. Соблюдение лучших практик, таких как компактность и декомпозиция, обеспечивает эффективное использование правил, делая их незаменимым инструментом для современных разработчиков.

---

_Пожалуйста, заполни записку прямо в этом файле — отмечай галочками, пиши комментарии, добавляй свои пункты! После твоих ответов я всё обработаю, зафиксирую решения и подготовлю следующую итерацию или draft-файлы._ 