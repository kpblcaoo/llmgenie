---
description:
globs:
alwaysApply: false
---
## Meta
# Modular Architecture Patterns (Atomic)
- Epic 5 Phase 3.1 best practices for modular multi-agent systems
- Single responsibility per module, beautiful tree structure
- Composition over inheritance, async-first design

## Best Practices from Epic 5 Multi-Agent Orchestration

### 1. **Beautiful Modular Tree Structure**
```
src/package/feature/
├── core/           # Data models and enums only
├── executors/      # Strategy implementations  
├── coordination/   # Communication logic
└── main_class.py   # Composition orchestrator
```

**Benefits:**
- Single responsibility per module
- Easy testing and maintenance
- Clear separation of concerns
- Beautiful visual structure

### 2. **Core Module Pattern**
- **execution_modes.py**: Enums with smart suggestions
- **coordination_types.py**: Types with compatibility matrices
- **task_models.py**: Dataclasses with comprehensive metadata

**Rule:** Core modules contain ONLY data structures, no business logic

### 3. **Executor Strategy Pattern**
```python
class ParallelExecutor:
    async def execute(self, task: OrchestrationTask) -> OrchestrationResult
class SequentialExecutor:
    async def execute(self, task: OrchestrationTask) -> OrchestrationResult  
class CollaborativeExecutor:
    async def execute(self, task: OrchestrationTask) -> OrchestrationResult
```

**Benefits:**
- Identical interface across strategies
- Easy to add new execution modes
- Independent testing

### 4. **Composition Over Inheritance**
```python
class AgentOrchestrator:
    def __init__(self, agent_routers: Dict[str, ModelRouter]):
        self.parallel_executor = ParallelExecutor(agent_routers)
        self.sequential_executor = SequentialExecutor(agent_routers)
        self.collaborative_executor = CollaborativeExecutor(agent_routers)
```

**Rule:** Compose existing components instead of modifying them

### 5. **Integration Points Design**
- Use existing components as building blocks
- Extend capabilities without breaking changes
- Maintain backward compatibility
- Clean interface boundaries

### 6. **Quality Metrics Pattern**
```python
OrchestrationResult(
    execution_time=duration,
    coordination_efficiency=success_rate, 
    quality_score=best_quality,
    metadata=comprehensive_context
)
```

**Rule:** Every orchestration provides comprehensive metrics for analysis

### 7. **Auto-Selection with Fallbacks**
```python
# Smart defaults with manual override capability
execution_mode = mode or await self._suggest_execution_mode(query)
coordination_type = coord or self._suggest_coordination_type(execution_mode)
```

**Benefits:**
- Easy to use (auto-mode)
- Flexible for experts (manual override)
- Always works (fallback logic)

## @-References
- @epic5_orchestration: Epic 5 Phase 3.1 implementation
- @session_log: For logging architecture decisions
- @documentation: docs/orchestration/MULTI_AGENT_ORCHESTRATION_GUIDE.md

## Fallback
- If implementation deviates from patterns, document reasoning in session_log
- Always maintain single responsibility principle

## Lessons Learned
- Beautiful architecture = easier maintenance
- Modular testing = faster debugging  
- Composition = more flexible than inheritance
- Comprehensive metrics = better optimization
- Auto-selection = better UX
